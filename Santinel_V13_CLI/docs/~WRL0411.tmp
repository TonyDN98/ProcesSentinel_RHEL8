<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Proiect Tehnic – Process Monitor Service (Santinel V13 CLI)</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; line-height: 1.4; color: #111; }
    h1, h2, h3 { color: #0b3d5c; }
    code, pre { font-family: Consolas, "Courier New", monospace; }
    pre { background: #f6f8fa; padding: 10px; border: 1px solid #e1e4e8; border-radius: 4px; }
    table { border-collapse: collapse; width: 100%; margin: 12px 0; }
    th, td { border: 1px solid #ddd; padding: 8px; }
    th { background: #f2f2f2; text-align: left; }
    .small { color: #555; font-size: 12px; }
    .kbd { border: 1px solid #bbb; border-bottom-width: 2px; padding: 2px 4px; border-radius: 3px; background: #f9f9f9; font-family: Consolas, "Courier New", monospace; }
  </style>
</head>
<body>
  <h1>Proiect Tehnic – Process Monitor Service (Santinel V13 CLI)</h1>
  <p class="small">Versiune document: 1.0 | Data: 2025-08-11</p>

  <h2>1. Context și scop</h2>
  <p>
    Acest document descrie arhitectura, componentele, fluxurile, schema bazei de date,
    configurarea, instalarea, operarea și procedurile de mentenanță pentru proiectul
    <strong>Process Monitor Service</strong>. Soluția monitorizează procese critice definite într-o
    bază de date MySQL și le repornește automat când intră în stare de alarmă.
  </p>

  <h2>2. Arhitectură și flux</h2>
  <h3>2.1 Componente principale</h3>
  <ul>
    <li><span class="kbd">monitor_service.sh</span>: scriptul principal care citește configurația,
      interoghează baza de date (tabelele <em>STATUS_PROCESS</em> și <em>PROCESE</em>),
      aplică <em>circuit breaker</em>, execută strategii de restart și health check,
      scrie loguri și expune o interfață CLI.</li>
    <li><span class="kbd">config.ini</span>: fișier INI ce definește conexiunea la MySQL, intervalele
      de monitorizare, rotația logurilor și strategii per-proces.</li>
    <li><span class="kbd">monitor_service.service</span>: unitate <em>systemd</em> pentru rulare ca serviciu.</li>
    <li><span class="kbd">monitor_service.8</span>: pagină <em>man</em> (documentație utilizator).</li>
    <li><span class="kbd">test_alarm.sh</span>: script de test ce setează alarme în DB pentru scenarii de probă.</li>
    <li><span class="kbd">setup.sql</span>: script SQL care creează schema, date exemplu și indexuri.</li>
  </ul>

  <h3>2.2 Flux de lucru (high-level)</h3>
  <ol>
    <li>Serviciul pornește prin <span class="kbd">systemd</span> și execută <span class="kbd">monitor_service.sh</span> din directorul de lucru.</li>
    <li>Scriptul citește <span class="kbd">config.ini</span> și validează valorile critice.</li>
    <li>Periodic (conform <em>check_interval</em>), interoghează DB pentru procese în alarmă (<em>alarma=1</em>, <em>sound=0</em>).</li>
    <li>Pentru fiecare proces în alarmă: verifică <em>circuit breaker</em>, execută eventual <em>pre-restart</em>, aplică strategia de restart, rulează <em>health check</em>.</li>
    <li>La succes, actualizează câmpurile din DB (doar în medii de test, cf. note) și resetează contorul de eșecuri; la eșec, incrementează contorul și poate deschide <em>circuit breaker</em>.</li>
    <li>Scrie loguri în <span class="kbd">/var/log/monitor_service.log</span> cu rotație configurabilă.</li>
  </ol>

  <h2>3. Baza de date</h2>
  <h3>3.1 Schema (din <code>setup.sql</code>)</h3>
  <table>
    <thead>
      <tr><th>Tabel</th><th>Câmp</th><th>Tip</th><th>Constrângeri / Note</th></tr>
    </thead>
    <tbody>
      <tr><td rowspan="4">STATUS_PROCESS</td><td>process_id</td><td>INT</td><td>PRIMARY KEY</td></tr>
      <tr><td>alarma</td><td>TINYINT</td><td>NOT NULL DEFAULT 0</td></tr>
      <tr><td>sound</td><td>TINYINT</td><td>NOT NULL DEFAULT 0</td></tr>
      <tr><td>notes</td><td>VARCHAR(100)</td><td>Comentarii/status text</td></tr>

      <tr><td rowspan="2">PROCESE</td><td>process_id</td><td>INT</td><td>PRIMARY KEY, FK → STATUS_PROCESS(process_id)</td></tr>
      <tr><td>process_name</td><td>VARCHAR(100)</td><td>NOT NULL</td></tr>
    </tbody>
  </table>
  <p>Indexuri: <code>CREATE INDEX idx_alarma ON STATUS_PROCESS(alarma);</code></p>
  <p>Exemple de procese: sshd, firewalld, NetworkManager, rsyslogd, chronyd, polkitd, cupsd, tuned, auditd, crond, httpd, podman.</p>

  <h3>3.2 Interogări utilizate de serviciu</h3>
  <ul>
    <li>Selecție procese în alarmă:
      <pre>SELECT p.process_id|process_name|alarma|sound|notes FROM join STATUS_PROCESS + PROCESE WHERE alarma=1 AND sound=0</pre>
      Implementat prin <span class="kbd">mysql --defaults-file</span> cu fișier temporar de credențiale.</li>
    <li>Actualizare (doar test):
      <pre>UPDATE STATUS_PROCESS SET alarma=0, notes=CONCAT(...)</pre>
      Notă: în producție se recomandă cont <em>read-only</em>; actualizarea este marcată pentru eliminare.</li>
  </ul>

  <h2>4. Configurare (<code>config.ini</code>)</h2>
  <h3>4.1 Secțiuni</h3>
  <ul>
    <li><strong>[database]</strong>: <em>host</em>, <em>user</em>, <em>password</em>, <em>database</em></li>
    <li><strong>[monitor]</strong>: <em>check_interval</em> (s), <em>max_restart_failures</em>, <em>circuit_reset_time</em> (s)</li>
    <li><strong>[logging]</strong>: <em>max_log_size</em> (KB), <em>log_files_to_keep</em></li>
    <li><strong>[process.&lt;nume&gt;]</strong>:
      <ul>
        <li><em>restart_strategy</em>: <span class="kbd">service</span> | <span class="kbd">custom</span> | <span class="kbd">process</span></li>
        <li><em>restart_command</em> (pentru <span class="kbd">custom</span>)</li>
        <li><em>health_check_command</em> (+ <em>health_check_timeout</em>)</li>
        <li><em>system_name</em> (alias pentru servicii cu nume diferit)</li>
        <li><em>restart_delay</em>, <em>max_attempts</em>, <em>pre_restart_command</em></li>
      </ul>
    </li>
  </ul>
  <p>
    Implicit, <code>[process.default]</code> setează <code>restart_strategy = auto</code>. În versiunea curentă a scriptului,
    valoarea <strong>auto</strong> nu este implementată în funcția de restart și va genera mesaj
    „Unknown restart strategy”. Recomandat: setați explicit strategia pentru fiecare proces.
  </p>

  <h3>4.2 Exemple de intrări per-proces</h3>
  <pre>[process.sshd]
restart_strategy = custom
restart_command = systemctl restart sshd
health_check_command = systemctl is-active sshd
health_check_timeout = 5
restart_delay = 5
max_attempts = 3</pre>

  <h2>5. Serviciul principal (<code>monitor_service.sh</code>)</h2>
  <h3>5.1 Jurnalizare și rotație</h3>
  <ul>
    <li>Fișier log: <span class="kbd">/var/log/monitor_service.log</span></li>
    <li>Rotație: la depășirea <em>max_log_size</em> (KB) se rulează rotație simplă, păstrând
      <em>log_files_to_keep</em> fișiere. Niveluri: INFO/DEBUG/WARNING/ERROR/CRITICAL (ERROR/CRITICAL și în syslog).</li>
  </ul>

  <h3>5.2 Funcționalități cheie (funcții)</h3>
  <ul>
    <li><strong>read_config</strong>: citește <code>config.ini</code>, validează și exportă variabile.</li>
    <li><strong>get_alarm_processes</strong>: interoghează DB pentru procese în alarmă (folosește fișier temporar de credențiale).</li>
    <li><strong>get_process_config</strong>: ia parametri per-proces cu fallback la <code>[process.default]</code>.</li>
    <li><strong>get_system_name</strong>: obține aliasul <em>system_name</em> (ex. <code>rsyslogd</code> → <code>rsyslog</code>).</li>
    <li><strong>execute_pre_restart</strong>: execută comandă pre-restart dacă e configurată.</li>
    <li><strong>perform_health_check</strong>: rulează health check cu retry până la <em>timeout</em>.</li>
    <li><strong>get_restart_strategy</strong>: citește strategia per-proces.</li>
    <li><strong>restart_process</strong>: implementează strategiile <em>custom</em>/<em>service</em>/<em>process</em>, cu health check după fiecare încercare și retry până la <em>max_attempts</em>.</li>
    <li><strong>update_alarm_status</strong>: actualizează DB (only for testing; planificat pentru eliminare).</li>
    <li><strong>check_circuit_breaker / update_circuit_breaker</strong>: previn „thrashing”-ul la eșecuri repetate.</li>
    <li><strong>main</strong>: bucla principală; expune CLI: <span class="kbd">--status</span>, <span class="kbd">--restart &lt;proces&gt;</span>, <span class="kbd">--help</span>.</li>
  </ul>

  <h3>5.3 Strategii de restart</h3>
  <ul>
    <li><strong>service</strong>: verifică <code>systemctl is-active</code>; pornește cu <code>start</code> sau repornește cu <code>restart</code>.</li>
    <li><strong>custom</strong>: execută <code>restart_command</code> definit; altfel fallback ca la <em>service</em>.</li>
    <li><strong>process</strong>: verifică cu <code>pgrep</code>; pornește binarul direct sau îl oprește cu <code>pkill</code> și îl repornește.</li>
  </ul>
  <p><strong>Notă:</strong> strategia <em>auto</em> nu e implementată în această versiune; setați explicit strategia.</p>

  <h3>5.4 Circuit breaker</h3>
  <p>
    După <em>MAX_RESTART_FAILURES</em> eșecuri consecutive, circuitul se deschide pentru procesul respectiv; reluarea încercărilor are loc după <em>CIRCUIT_RESET_TIME</em> secunde.
  </p>

  <h2>6. Unitatea systemd (<code>monitor_service.service</code>)</h2>
  <ul>
    <li><strong>WorkingDirectory</strong>: <span class="kbd">/opt/monitor_service</span></li>
    <li><strong>ExecStart</strong>: <span class="kbd">/opt/monitor_service/monitor_service.sh</span></li>
    <li><strong>Restart</strong>: always, <strong>RestartSec</strong>: 10s; <strong>SyslogIdentifier</strong>: <span class="kbd">monitor_service</span></li>
    <li>Dependențe: <span class="kbd">After=network.target mysql.service</span></li>
  </ul>

  <h2>7. Pagină man (<code>monitor_service.8</code>)</h2>
  <p>Oferă sinopsisul opțiunilor CLI, exemplu de configurare și locații de fișiere: <span class="kbd">/opt/monitor_service/config.ini</span>, <span class="kbd">/var/log/monitor_service.log</span>, <span class="kbd">/etc/systemd/system/monitor_service.service</span>.</p>

  <h2>8. Script test (<code>test_alarm.sh</code>)</h2>
  <ul>
    <li>Folosește aceleași credențiale din <code>config.ini</code>.</li>
    <li>Oferă meniu pentru: listare servicii, setare alarmă pe un serviciu/an toate, reset alarme.</li>
    <li>Util de validat capăt‑la‑capăt: DB → serviciu → log/CLI.</li>
  </ul>

  <h2>9. Instalare și configurare</h2>
  <h3>9.1 Dependențe</h3>
  <ul>
    <li>Linux cu <span class="kbd">systemd</span>, <span class="kbd">bash</span>, <span class="kbd">mysql</span> client, <span class="kbd">pgrep/pkill</span>.</li>
  </ul>
  <h3>9.2 Pași de instalare</h3>
  <ol>
    <li>Creați directorul: <span class="kbd">/opt/monitor_service</span> și copiați fișierele proiectului.</li>
    <li>Permisiuni: <span class="kbd">chmod +x /opt/monitor_service/monitor_service.sh /opt/monitor_service/test_alarm.sh</span></li>
    <li>Configurați <span class="kbd">/opt/monitor_service/config.ini</span> (conexiune DB + procese).</li>
    <li>Instalați unitatea: copiați <span class="kbd">monitor_service.service</span> în <span class="kbd">/etc/systemd/system/</span>, apoi:
      <pre>sudo systemctl daemon-reload
sudo systemctl enable monitor_service
sudo systemctl start monitor_service
sudo systemctl status monitor_service</pre></li>
    <li>Inițializați DB (opțional de test):
      <pre>mysql -u root -p &lt; setup.sql</pre></li>
  </ol>

  <h2>10. Operare</h2>
  <ul>
    <li>CLI direct:
      <pre>./monitor_service.sh --status
./monitor_service.sh --restart sshd
./monitor_service.sh --help</pre></li>
    <li>Jurnale: <span class="kbd">/var/log/monitor_service.log</span> și <span class="kbd">journalctl -u monitor_service</span></li>
  </ul>

  <h2>11. Securitate</h2>
  <ul>
    <li>Folosiți un utilizator MySQL dedicat cu drepturi minime. În producție, <strong>evitați UPDATE</strong>-uri din serviciu (mențineți <em>read-only</em>).</li>
    <li>Scriptul transmite credențiale MySQL prin fișiere temporare (<span class="kbd">--defaults-file</span>); acestea sunt șterse imediat după execuție.</li>
    <li>Protejați <code>config.ini</code> (permisiuni restrictive) deoarece conține parole.</li>
  </ul>

  <h2>12. Considerații de fiabilitate</h2>
  <ul>
    <li><strong>Circuit breaker</strong> reduce tentativa de restart repetitivă pentru procese cu probleme persistente.</li>
    <li><strong>Rotație loguri</strong> previne creșterea necontrolată a fișierelor de jurnal.</li>
    <li><strong>Health check</strong> configurabil per-proces după fiecare restart.</li>
  </ul>

  <h2>13. Depanare</h2>
  <ul>
    <li>„Unknown restart strategy”: setați explicit <code>restart_strategy</code> la <em>service</em> / <em>custom</em> / <em>process</em>.</li>
    <li>Conexiune DB eșuată: validați <code>[database]</code>, firewall și accesul utilizatorului MySQL.</li>
    <li>Health check eșuează: ajustați <code>health_check_command</code> și <code>health_check_timeout</code>.</li>
    <li>Permisiuni <code>systemctl</code>: rulați serviciul ca utilizator cu drepturi suficiente sau configurați <code>sudo</code> adecvat.</li>
  </ul>

  <h2>14. Îmbunătățiri viitoare</h2>
  <ul>
    <li>Implementare comportament pentru <strong>restart_strategy = auto</strong> (ex. auto-detect între service/process).</li>
    <li>Metadate suplimentare în DB (ex. comenzi start/stop/health per-proces).</li>
    <li>Export metrici (prometheus) și praguri configurabile per-proces.</li>
  </ul>

  <h2>15. Anexe</h2>
  <h3>15.1 Chei de configurare – sumar</h3>
  <table>
    <thead>
      <tr><th>Cheie</th><th>Valoare/Tip</th><th>Implicit</th><th>Descriere</th></tr>
    </thead>
    <tbody>
      <tr><td>[monitor] check_interval</td><td>int (sec)</td><td>120</td><td>Interval între interogările DB</td></tr>
      <tr><td>[monitor] max_restart_failures</td><td>int</td><td>3</td><td>Număr eșecuri până la CB open</td></tr>
      <tr><td>[monitor] circuit_reset_time</td><td>int (sec)</td><td>600</td><td>Timp până la reset CB</td></tr>
      <tr><td>[logging] max_log_size</td><td>int (KB)</td><td>5120</td><td>Dimensiune max. log înainte de rotație</td></tr>
      <tr><td>[logging] log_files_to_keep</td><td>int</td><td>5</td><td>Număr fișiere păstrate</td></tr>
      <tr><td>[process.*] restart_strategy</td><td>enum</td><td>(auto)</td><td>service | custom | process (recomandat explicit)</td></tr>
      <tr><td>[process.*] restart_command</td><td>string</td><td>-</td><td>Comandă custom pentru restart</td></tr>
      <tr><td>[process.*] health_check_command</td><td>string</td><td>pgrep %s</td><td>Comandă verificare stare</td></tr>
      <tr><td>[process.*] health_check_timeout</td><td>int (sec)</td><td>5</td><td>Timeout health check</td></tr>
      <tr><td>[process.*] restart_delay</td><td>int (sec)</td><td>2</td><td>Pauză între încercări</td></tr>
      <tr><td>[process.*] max_attempts</td><td>int</td><td>2</td><td>Încercări de restart</td></tr>
      <tr><td>[process.*] pre_restart_command</td><td>string</td><td>-</td><td>Comandă premergătoare restartului</td></tr>
      <tr><td>[process.*] system_name</td><td>string</td><td>-</td><td>Alias pentru nume de serviciu diferit</td></tr>
    </tbody>
  </table>

  <p class="small">Acest document este livrat ca fișier .doc în format HTML, compatibil cu Microsoft Word.</p>
</body>
</html>


